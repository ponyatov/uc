% ebook header
\documentclass[oneside,10pt]{article}
\usepackage[paperwidth=118.8mm,paperheight=68.2mm,margin=2mm]{geometry}
\renewcommand{\familydefault}{\sfdefault}\normalfont
\usepackage[unicode,colorlinks=true]{hyperref}
\usepackage[pdftex]{graphicx}
\newcommand{\fig}[3]{\noindent\includegraphics[#3]{#2}\\\textbf{#1}}
\newcommand{\figno}[2]{\noindent\includegraphics[#2]{#1}}
\usepackage{enumitem}
%% Cyrillization
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
% xcolor fixes
\usepackage{xcolor}
\definecolor{red}{rgb}{0.7,0,0}		% R
\definecolor{green}{rgb}{0,0.6,0}	% G
\definecolor{blue}{rgb}{0,0,0.7}	% B
%% misc
\renewcommand{\emph}[1]{\textcolor{blue}{#1}}
\newcommand{\note}[1]{\,\footnote{\ #1}}
\newcommand{\cp}[1]{\note{\copyright\ #1}}
\newcommand{\email}[1]{$<$\href{mailto:#1}{#1}$>$}
\newcommand{\term}[1]{\textcolor{green}{#1}}
\newcommand{\error}[1]{\textcolor{red}{#1}}
\usepackage{framed}
%% lang
\newcommand{\cpp}{$C^+_+$}
\newcommand{\java}{$Jaba$}
\newcommand{\py}{$Python$}
%% prog
\newcommand{\prog}[1]{\textbf{#1}}
\newcommand{\file}[1]{\textit{#1}}
\newcommand{\make}{\prog{make}}
\newcommand{\git}{\prog{git}}
\newcommand{\gvim}{\prog{(g)Vim}}
\newcommand{\flex}{\prog{flex}}
\newcommand{\lex}{\prog{lex}}
\newcommand{\yacc}{\prog{yacc}}
\newcommand{\bison}{\prog{bison}}
\newcommand{\gpp}{\prog{g++}}
\newcommand{\eclipse}{\prog{eclipse}}
%% listings
\usepackage{listings}
\lstset{
basicstyle=\small,
frame=single,
tabsize=4,
}
\newcommand{\lst}[2]{\lstinputlisting[title=#1]{#2}}

\title{$\mu$Compiler: микрокомпилятор}
\author{\copyright\ Dmitry Ponyatov \email{dponyatov@gmail.com}}

\begin{document}
\maketitle
\begin{abstract}
Рассмотрена реализация компилятора для простейшего арифметического языка на
\flex/\bison/\cpp.
\end{abstract}
\clearpage\tableofcontents\clearpage

\section{Необходимое программное обеспечение}

\begin{itemize}
  \item пакет {mingw}\note{\url{http://www.mingw.org/}}: нужны пакеты
  \gpp\ \make\ \flex\ \bison
  \item рекомендуется текстовый редактор
  \gvim\note{\url{http://vim.sourceforge.net/download.php\#pc}}
\end{itemize}

\section{Структура проекта (lexical skeleton)}

\begin{tabular}{l l l}
src.src & script & тестовый скрипт на нашем языке \\
log.log & & лог выполнения компилятора \\
ypp.ypp & \yacc & описание синтаксиса (грамматика) \\
lpp.lpp & \lex & регулярные выражения для лексем \\
hpp.hpp & \cpp & общие хедеры \\
cpp.cpp & \cpp & \\
.gitignore & \git & маски файлов не включаемых в проект \\
bat.bat & \gvim & helper для запуска редактора \\
Makefile & \make & скрипт сборки проекта \\
\end{tabular}

\lst{\file{core.src}: ядро компилятора}{doc/core.src}
% \lst{\file{files.src}: файлы проекта}{doc/files.src}

\fig{файлы типового проекта лексической
программы}{files.pdf}{width=\textwidth}

\subsection{Структура типичного компилятора}

\fig{}{compiler.pdf}{width=\textwidth}

\fig{}{frontback.pdf}{width=0.8\textwidth}

\begin{description}[nosep]
\item[frontend]\ \\язык программирования транслируется в промежуточную форму
(IL)\note{[I]ntermediate [L]anguage} \begin{description}[nosep]
\item[лексер]
\item[парсер]
\item[оптимизатор промежуточного представления]
\end{description}
\item[backend] промежуточная форма (IL) компилируется в машинный код конкретной
\term{целевой машины}
\begin{description}[nosep]
\item[оптимизатор целевой машины]
\item[кодогенератор]
\end{description}
\end{description}

\subsection{Сборка проекта утилитой [mingw32-]\make}

\lst{Makefile}{doc/00.mk}

\section{Лексер}

\term{Лексический анализ}\ --- группировка единичных символов входного потока
(исходного кода) в токены. \term{Токен} можно рассматривать как пару из двух
элементов:
\begin{description}[nosep]
\item[тэг]\ \\маркер типа токена: идентификатор, число, оператор,\ldots
\item[\term{лексема}]\ \\текстовое значение токена, полученное группировкой
  нескольких символов 
\end{description}

\bigskip
В нашем компиляторе будем использовать генератор лексеров\ --- программу \flex.

\subsection{Тестовый файл \#00}

Рассмотрим разбор следующего тестового файла:
\lst{\file{src.src}: тест \#00}{doc/00.src}

\clearpage
Как мы видим он состоит из следующих элементов:
\begin{itemize}[nosep]
  \item \# комментарий
  \item выражение с присвоением переменной
  \item \term{директива} \verb|.end|
  \item некая ахинея похожая на список файлов проекта\note{возможно когда-нибудь
  наш компилятор сможет сгененировать собственный исходник из высокоуровневого
  описания}
\end{itemize}

\bigskip
Измените \file{Makefile} чтобы при сборке проекта использовался только лексер:
\lst{\file{Makefile}: изоляция лексера}{doc/01.mk}

\subsection{Структура файла лексера}

\begin{verbatim}
%{
С(++) код включаемый в начало сгенерированного lex.yy.c
%}

%option ... /* опции */

%%
набор пар
<регулярное выражение>:<С(++) действие над выделенной лексемой> 
%%

любой дополнительный С(++) код, например int main()
\end{verbatim}

\lst{\file{lpp.lpp}: пустой лексер}{doc/00.lpp}
транслируется командой \verb|mingw32-make| в \file{lex.yy.c}, но
\lst{\file{log.log}: ошибки}{doc/00.llg}

\clearpage
добавим пару опций
\lst{\file{lpp.lpp}: пустой лексер}{doc/01.lpp}
\lst{\file{log.log}: bypass исходного кода}{doc/01.llg}

Все нераспознанные лексером символы входного потока по умолчанию копируются в
выходной без изменений. Неплохо, но тот же результат проще получить командой
копирования.

\bigskip
Добавим несколько регулярных выражений, которые
\begin{itemize}
  \item удалят все комментарии
  \item удалят все пробельные символы\note{обычно в языках программирования они
  имеют только фунцию улучшения читаемости, но не забываем про \py} и
  \item остановят разбор по директиве \verb|.end|
\end{itemize}

\noindent
Не забудьте про обязательный символ конца последней строки\ --- редактируя
\file{lpp.lpp} в \eclipse\ я получил ошибку \error{lpp.lpp:5: EOF encountered
inside an action}

\lst{\file{lpp.lpp}: удаление лишнего}{doc/02.lpp}
\lst{\file{log.log}: остались только значащие символы}{doc/02.llg}

\subsection{\term{regexp}: регулярные выражения}

\begin{tabular}{l l}
\verb|.| & любой символ кроме \verb|\n| \\
\verb|\n| & конец строки \\
\verb|\r| & огрызок Micro\$oft \\
\verb|\t| & табуляция \\
\verb|(...)| & группа \\
\verb|()?| & необязательное вхождение \\
\verb|()*| & \emph{0}+ повторений \\
\verb|()+| & \emph{1}+ повторений \\
\verb|[...]| & один из символов набора \ldots \\
\verb|[^...]| & любой символ \emph{кроме} \ldots \\
\verb|{x}| & подстановка макрорегулярки определенной отдельно \\
\end{tabular}

\subsection{Лексемы тестового примера}

И наконец выделим числа, операторы и переменные:

\lst{\file{lpp.lpp}: полный набор \term{regexp}ов}{doc/03.lpp}
\lst{\file{lpp.lpp}: числа (несколько вариантов)}{doc/04.lpp}
пришлось перенести, в файле должны быть в одну строку
\lst{\file{log.log}: числа}{doc/04.llg}
\clearpage
\lst{\file{lpp.lpp}: имена и операторы}{doc/05.lpp}
\clearpage
\lst{\file{log.log}: имена и операторы}{doc/05.llg}

\clearpage
\section{Грамматика: (мета)язык описания языков}

Языки формируют ландшафт информатики и вычислений
\cp{\url{http://matt.might.net/articles/grammars-bnf-ebnf/}}:
языки программирования, спецификации протоколов, языки запросов, форматы файлов,
языки определения шаблонов, карты памяти, формальные языки, конфигурационные
файлы и языков разметки, языки форматирования, абстрактные языки математики и
метаязыки формируют колею использования компьютеров и вычислений.
\begin{framed}
\term{Грамматика} это язык описания языков, или \term{метаязык}.
\end{framed}
А что определяет сам язык\,?
За каждым языком стоит \term{грамматика}, которая определяет его структуру.

\noindent
Кратко рассмотрим широко известный метаязык Backus-Naur Form
(BNF)\note{форма Бахуса--Наура}, и пару его разновидностей: Extended
Backus-Naur Form (EBNF) и регулярные расширения BNF.

\subsection{Определение языка}

Язык определяется грамматикой. В информатике преимущественно используются
\term{контекстно-свободные грамматики}, и нам их будет достаточно:
\term{КС-грамматики} имеют достаточную описательную силу, чтобы определить
рекурсивную структуру большинства (но не всех) компьютерных языков и текстовых
форматов данных.

\subsection{Компоненты контекстно-свободной грамматики}

\clearpage
\section{Синтаксический разбор}

Для разбора вложенных конструкций, таких как математические выражения,
регулярные выражения не подходят. В дело вступает (E)BNF нотация, в которой
может быть описана грамматика почти любого языка программирования\note{за
исключением особо клинических случаев типа \java\ и \cpp} или текстовоо формата
данных.

Так как тема разбора обсасывалась со всех сторон со времен появления первых
компиляторов, она считается $\pm$решенной проблемой информатики, и для описания
\term{грамматики} языка давно существует даже стандарт нотации
(E)BNF\note{[E]xtended [B]ackus--[N]aur [F]orm notation, (расширенная) форма
Бахуса--Наура}:
\begin{itemize}
  \item
  \href{https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0_%D0%91%D1%8D%D0%BA%D1%83%D1%81%D0%B0_%E2%80%94_%D0%9D%D0%B0%D1%83%D1%80%D0%B0}{wiki}
  расширенная форма Бэкуса--Наура
  \item
  \href{https://groups.google.com/forum/?hl=ru#!forum/localizations}{Локализация}
  стандарта
  \href{http://standards.iso.org/ittf/PubliclyAvailableStandards/s026153_ISO_IEC_14977_1996(E).zip}{ISO/IEC
  14977:1996(E) (Extended BNF)}
\end{itemize}

\subsection{Расширенная форма Бэкуса--Наура}

Согласно Википедии\note{\emph{wikipedia всегда предпочтительнее английская
версия}\ --- в русской даже ссылки на статьи и инструменты перенести не могут, и
объем текста часто на порядок меньше}, EBNF\ --- семейство
\term{метаязыков}\note{язык для описания языка} для описания грамматик
контекстно-свободных языков\note{за подробностями и терминами\ --- просим в
Книгу Дракона \cite{dragon}}. Грамматика описывается в виде набора правил,
в котором одни синтаксические элементы последовательно определяются через
другие.
Стандарт ISO/IEC 14977:1996(E) определяет EBNF как \term{синтаксический
метаязык}.

\clearpage
Правила состоят из
\begin{description}[nosep]
  \item[ \term{терминал}ов = терминальных символов] и\ \\
  \term{терминал}\ --- минимальный элемент грамматики, не имеющий собственной
  грамматической структуры. В качестве терминалов должны рассматриваться
  прежде всего \term{токен}ы, возвращаемые лексером, но иногда используют
  просто \term{цепочки} символов в кавычках.
  \item[ \term{нетерминал}ов = продукционных правил]\ \\
  \term{нетерминал}\ --- элемент грамматики, имеющий собственное имя и
  структуру.
\end{description}

% \begin{verbatim}
% язык   = калькулятор
% \end{verbatim}
% 
% \begin{verbatim}
% // в описании грамматики нам нужно задать список токенов
% // он будет передан лексеру
% токены = [ переменная число = + - * / ^ ]
% \end{verbatim}
% 
% \begin{verbatim}
% // [R]ead [E]val [P]rint [L]oop
% // цикл  
% REPL := выражение * { вывести выражение }
% выражение := символ 
% \end{verbatim}

\clearpage
\subsection{Ассоциативность операторов}

\noindent
\begin{tabular}{p{0.5\textwidth} p{0.5\textwidth}}
\begin{minipage}{0.5\textwidth}
\figno{L.pdf}{width=.8\textwidth}
\end{minipage}
&
\begin{minipage}{0.5\textwidth}
\figno{R.pdf}{width=.8\textwidth}
\end{minipage}
\\
\emph{лево}ассоциативный разбор&
\emph{право}ассоциативный разбор\\
$A+B+C$&$A=B=C$\\
\end{tabular}

\clearpage
\subsection{Приоритет операторов}

\subsection{Структура файла парсера}

Структура файла парсера \file{ypp.ypp}\ аналогична файлу лексера: 

\begin{verbatim}
%{
С(++) код включаемый в начало сгенерированного ypp.tab.cpp
%}

%defines %union { <перечень типов узлов дерева разбора >}

%token<тип1> токен11 токен12 \ldots
%token<тип2> токен21 токен22 \ldots

%type <тип> <список нетерминалов>

%%
<продукционные правила c блоками С(++) кода
  выполняемого при срабатывании правила>
%%

любой дополнительный С(++) код, например int main()
\end{verbatim}


\end{document}
